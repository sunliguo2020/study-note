			Linux管理员手册(1)
  			--Linux系统概述

本章概述Linux系统。首先描述操作系统提供的主要服务。然后说明实现这些服务的程序 with a considerable lack of detail。本章的目的是理解系统整体，以后再详细说明每个部分.

一个操作系统的不同部分

　　一个UNIX操作系统包括一个核心程序kernel和一些系统程序system programs。还有一些做某件事情的应用程序application programs。核心是操作系统的心脏。它跟踪磁盘上的文件，启动程序并运行它们，给不同的进程分配内存和其他资源，从网络接收和向网络发送包，等等。核心很少自己干活，但它提供工具，用这些工具可以建立所有服务。它还阻止任何人直接存取硬件，强制每个人使用它提供的工具。这样，核心给每个用户与其他用户之间提供保护。核心提供的工具通过系统调用system calls使用；
　　系统程序使用核心提供的工具实现操作系统要求的不同的服务。系统程序和所有其他程序运行在核心之上，叫做用户模式user mode。系统程序和应用程序的区别是目的：应用程序意图完成一些有用的工作(或游戏)，而系统程序则为系统工作而需要。字处理器是应用；telnet 是系统程序。区别经常有些模糊，也许，只是为了强制分类。
　　虽然编程语言不必是操作系统的一部分，操作系统也可以包括编译器及其相关的库(Linux下是gcc和C库)。文档、有时甚至游戏，可以是操作系统的一部分。传统上，操作系统被定义为安装磁带或磁盘上的内容；对于Linux就更不清楚，因为它分布在全世界的FTP站点上。

核心的重要部件

　　Linux核心包括几个重要部分：进程管理、存储器管理、硬件设备驱动、文件系统驱动、网络管理和其他不同的部分。

　　可能核心最重要的部分(没有它们什么也不能工作)是存储器管理和进程管理。存储器管理负责分配进程的存储器区域和对换空间区域、核心的部件及buffer cache。进程管理产生进程，用切换处理器上的活动进程来实现多任务。

　　在最低级，核心对它支持的每种硬件包含一个硬件设备驱动。因为世界上存在大量不同的硬件，硬件设备驱动的数量极大。有许多不同的硬件，因此软件控制方法不同。但其相似性可能分类驱动，支持相似的操作；每类的每个成员有相同的与核心其他部分接口，但具体实现是不同的。例如，所有的硬盘驱动与核心其他部分接口相同，即他们都有初始化驱动器、读N扇区、写N扇区。

　　核心自己提供的有些软件服务有类似的抽象属性，因此可以抽象分类。例如，不同的网络协议已经被抽象为一个编程接口：BSD socket库。另一个例子是虚拟文件系统virtual filesystem(VFS)层，它从文件系统操作实现中抽象出文件系统操作。每个文件系统类型提供了每个文件系统操作的实现。当一些实体企图使用一个文件系统时，请求通过VFS送出，它将请求发送到适当的文件系统驱动。


UNIX系统的主要服务

init

　　UNIX系统里最重要的服务是由init 提供的。 init 是每个UNIX系统在核心引导最后启动的第一个进程。 init 启动后，它做不同的启动工作继续引导过程(检查和mount文件系统、启动守侯程序等)
init 做的具体事情的列表依赖于用户意愿； init 有多个启动选择。通常提供单用户模式single user mode的概念，此时没有用户能登录，root 在控制台使用一个shell；通常的模式叫多用户模式multiuser mode。一般说来这称为运行级run levels；单用户和多用户模式可以理解为2个运行级，还可以有其他运行级，例如，在控制台上运行X。

　　在普通操作中，init 确认getty 正常运行(允许用户登录)，并收养孤儿进程(父进程已死的进程；UNIX中，所有进程必须在一棵树中，因此孤儿进程必须收养)。

　　当系统关闭时，init 负责杀死所有其他进程，unmount所有文件系统并停止处理器，根据设置。

从终端登录

　　从终端登录(通过串行线)和控制台(当不运行X时)是由getty 程序提供的。 init 为每个允许登录的终端启动一个单独的getty 实例 getty 读用户名并运行login 程序，由它读口令。如果用户名和口令正确，login 就运行shell。当shell终止时，即用户注销，或login 因用户名和口令不对而终止时， init 知道并启动一个新的getty 实例。核心没有登录的概念，这都由系统程序处理。

Syslog

　　核心和许多系统程序会产生错误、警告和其他信息。这些信息在以后能看经常是很重要的，甚至很久以后，所以它们应该被写到一个文件。这个程序是 syslog 。它能设置成根据输出信息的程序或重要程度将信息排序到不同的文件。例如，核心信息经常与其他信息分开，单独定向到一个分离的文件，因为核心信息经常更重要且需要有规律地阅读以确定问题。

定时执行命令: cron 和at

　　用户和系统管理员经常需要定时运行命令。例如,系统管理员可能想运行一个程序从老文件中清除暂存文件的目录 (/tmp 和/var/tmp )，以免磁盘满，因为并非所有程序都正确地清除自己的暂存文件。

　　cron 服务是做这个的。每个用户有个crontab ，在这里列出他要执行的命令和想执行的时间。 cron 守侯进程负责在特定的时间启动命令.

　　at 服务与cron 类似，但它只执行一次：命令在给定的时间执行，但不可自动重复。

图形用户接口GUI

　　UNIX和Linux不将用户接口合在核心中，而是用用户级程序实现。用户接口同时提供文本和图形环境。

　　这样的安排使系统更灵活，但有容易对每个程序实现不同的用户接口的缺点，使系统较难学。

　　Linux使用的主要的图形环境叫X Window系统(简称X)。 X也不实现用户接口；它只实现一个窗口系统，即可以实现图形用户接口的工具。 3种最流行的基于X实现的用户接口风格是Athena、Motif和Open Look。

网络

　　网络连接2台或更多的计算机使之能互相通信。连接和通信的实际方法有些复杂，但结果非常有用。

　　UNIX操作系统具有许多网络特征。最基本的服务：文件系统、打印、备份等都可以通过网络完成。这可使系统管理更简单，因为它允许集中管理，同时获得小型机和分布计算的优点，例如降低成本和更好的容错能力。

网络登录

　　网络登录与普通登录有一点不同。可以登录的每个终端各有一条单独的物理串行线。从网络登录的每个人，有一条单独的虚拟网络连接，并且可以有任意数量。因此不可能为每个可能的虚拟连接运行单独的getty 。通过网络登录有若干不同的方法， telnet 和rlogin 是TCP/IP网络中的主要方法。

　　网络登录为每种登录方法提供一个单独的守侯程序(telnet 和rlogin 使用不同的守侯程序)，而不是使用一群getty ，来侦听所有的输入的登录企图。当发现一个登录企图，就启动一个自己的新实例来处理这个企图；原来的实例继续侦听其他企图。新实例的工作和getty 类似。

网络文件系统

　　网络服务的一个最有用的东西是通过网络文件系统network file system共享文件。这个服务一般用Sun公司开发的网络文件系统Network File System，或NFS。

　　通过网络文件系统，任何文件操作可以由一台机器的一个程序通过网络发送到其他任何机器。这愚弄了程序，使它以为其他机器上的所有文件是在程序运行的机器上。这极大地简化了信息共享，因为它对程序无须任何修改。

邮件

　　电子邮件通常是通过计算机通信的最重要的方法。一封电子信件用特定的格式存储在一个文件中，使用特定的邮件程序来收发邮件。

　　每个用户有一个收件箱incoming mailbox(一个特定格式的文件)，所有新邮件存在这里。当什么人发送邮件时，邮件程序定位收件人的邮箱，并在邮箱文件中添加信件。如果收件人的邮箱在另一台机器上，信件就被发送到那台机器，由它用它觉得最合适的方法来投递邮箱。

　　邮件系统包括很多程序。投递邮件到本地或远程邮箱使用一个程序(mail transfer agent或MTA，例如，sendmail 或smail )，而用户使用的则有很多不同的程序(mail user agent或MUA，例如pine 或elm )。邮箱一般存在/var/spool/mail 中。

打印

　　同时只能有一个人使用某一台打印机，但各用户不共享打印机是不经济的。因此打印机由软件来管理，实现一个打印队列print queue：所有的打印任务放进一个队列，打印机完成一个任务后，自动再打印下一个。这无须用户来组织打印队列，回避了直接控制打印机。

　　打印队列软件也把打印输出spools到磁盘，即，当任务在队列中时，打印输出存在一个文件中。这允许应用程序快速地完成一个打印任务到打印队列程序，应用程序无须等到打印任务真正完成就可以继续下去。这真的很方便，因为它允许打印出一个版本，无须打印完成，就继续修改一个新版本。

文件系统布局

　　文件系统分为许多部分，通常从根文件系统有： /bin , /lib , /etc , /dev , 及一些其他； /usr 文件系统包含程序和不改变的数据； /var 文件系统包含改变的数据(例如log文件)； /home 文件系统包含每个用户的个人文件。依赖于硬件配置和系统管理员的决定，方法不同，甚至所有东西可能在一个文件系统中。

Linux 管理员手册(2)--目录树概述

　　本章说明标准Linux目录树的重要部分，基于FSSTND文件系统标准。概述根据不同的目的和给定的要求将目录树分为若干分离的文件系统的一般方法。也说明一些其他方法。

背景

　　本章松散地基于Linux文件系统标准FSSTND版本1.2(见参考书目[Qui95])，它意图建立一个如何组织Linux系统目录树的标准。这样一个标准具有易于写或port(移植?)Linux软件、管理Linux系统的优点，因为所有东西都将在他们的一般地方。此标准没有强制所有人遵从的权威，但它有最多的Linux distributions的支持。如果没有什么特殊的理由，不遵从FSSTND不是个好主意。 FSSTND意图遵从Unix传统和当前趋势，使熟悉其他Unix系统的人对Linux系统更容易接受(反之亦然)。

　　本章并非如FSSTND那么详细。一个系统管理员应该阅读FSSTND以得到全部的理解。

　　本章不详细解释所有文件。其意图并非说明每个文件，而是从文件系统的视角给出系统的一个概览。每个文件的更多的信息在本手册或man页的其他地方。

　　有意将全目录树可以分为小的部分，每个部分可以在自己的磁盘或分区上，以能为磁盘容量所容纳，并易于备份及其他系统管理。主要部分是根、/usr 、/var 和 /home 文件系统。每个部分有不同的目的。目录树已被设计成能在Linux机器的网络中很好地工作，可以通过只读设备(如CDROM)或NFS网络共享文件系统的一些部分。

　　下面说明目录树不同部分的任务。

　　每台机器都有根文件系统(一般在本地盘中，当然也可以在RAM盘或网络盘中)，它包含系统引导和使其他文件系统得以mount所必要的文件，根文件系统应该有单用户状态所必须的足够的内容。还应该包括修复损坏系统、恢复备份等的工具。

　　/usr 文件系统包含所有命令、库、man页和其他一般操作中所需的不改变的文件。 /usr 应该没有对给定机器特定的文件，也不应该有一般使用中要修改的文件。这样允许此文件系统中的文件通过网络共享，这样可以更有效，因为这样节省了磁盘空间 (/usr 很容易是数百兆)，且易于管理(当升级应用时，只有主/usr 需要改变，而无须改变每台机器) 即使此文件系统在本地盘上，也可以只读mount，以减少系统崩溃时文件系统的损坏。

　　/var 文件系统包含会改变的文件，比如spool目录(mail、news、打印机等用的)， log文件、formatted manual pages和暂存文件。传统上/var 的所有东西曾在 /usr 下的某个地方，但这样/usr 就不可能只读安装了。

　　/home 文件系统包含用户家目录，即系统上的所有实际数据。将家目录分到自己的目录树或文件系统中易于备份，其他部分经常不必备份，至少不必经常备份(它们很少改变)。一个大的/home 可能要分为若干文件系统，需要在/home 下加一级名字，如/home/students 、/home/staff 等。

　　虽然上面将不同的部分称为文件系统，但它们不必是真的分离的文件系统。如果系统是小的单用户系统，而用户希望简单化，可以很容易地放在一个文件系统中。根据磁盘容量和不同目的所需分配的空间，目录树也可以分到不同的文件系统中。重要的是使用标准的名字，即使/var 和/usr 在同一分区上，名字/usr/lib/libc.a 和/var/adm/messages 必须能工作，例如将/var 下的文件移动到/usr/var ，并将/var 作为/usr/var 的符号连接。

　　Unix文件结构根据目的来分组文件，即所有的命令在一个地方，所有的数据在另一个地方，所有的文档又在一个地方，等等。另一个方法是根据属于的程序分组文件，即所有Emacs文件在一个目录中，所有TeX文件在另一个中，等等。后一种方法的问题是文件难于共享(程序目录经常同时包含静态可共享的和动态不可共享的文件)，有时难于查找 (例如man页在极大数量的地方，使man程序查找它们极其困难)。

根文件系统

　　根文件系统一般应该比较小，因为包括严格的文件和一个小的不经常改变的文件系统不容易损坏。损坏的根文件系统一般意味着除非用特定的方法(例如从软盘)系统无法引导，所以不应该冒这个险。
　　根目录一般不含任何文件，除了可能的标准的系统引导映象，通常叫/vmlinuz 。所有其他文件在根文件系统的子目录中。

/bin
引导启动所需的命令或普通用户可能用的命令(可能在引导启动后)。

/sbin
类似/bin ，但不给普通用户使用，虽然如果必要且允许时可以使用。

/etc
特定机器的配置文件。

/root           root用户的家目录。

/lib           根文件系统上的程序所需的共享库。

/lib/modules   核心可加载模块，特别是那些恢复损坏系统时引导所需的(例如网络和文件系统驱动)。
/dev     设备文件。
/tmp    临时文件。引导启动后运行的程序应该使用/var/tmp ，而不是/tmp ，因为前者可能在一个拥有更多空间的磁盘上。
/boot   引导加载器(bootstrap loader)使用的文件，如LILO。核心映象也经常在这里，而不是在根目录。如果有许多核心映象，这个目录可能变得很大，这时可能使用单独的文件系统更好。另一个理由是要确保核心映象必须在IDE硬盘的前1024柱面内。
/mnt  系统管理员临时mount的安装点。程序并不自动支持安装到/mnt 。 /mnt 可以分为子目录(例如/mnt/dosa 可能是使用MSDOS文件系统的软驱，而/mnt/exta 可能是使用ext2文件系统的软驱)。

/proc , /usr , /var , /home
其他文件系统的安装点。

/etc目录
/etc 目录包含很多文件。下面说明其中的一些。其他的你应该知道它们属于哪个程序，并阅读该程序的man页。许多网络配置文件也在/etc 中，它们在《网络管理指南》中说明。

/etc/rc or /etc/rc.d or /etc/rc.d
启动、或改变运行级时运行的scripts或scripts的目录，更详细的信息见关于init 的章。

/etc/passwd
用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息。格式见passwd 的man页。

/etc/fdprm
软盘参数表。说明不同的软盘格式。用setfdprm 设置。更多的信息见setfdprm 的man页。

/etc/fstab
启动时mount -a命令(在/etc/rc 或等效的启动文件中)自动mount的文件系统列表。 Linux下，也包括用swapon -a启用的swap区的信息。见4.8.5节和mount 的man页。

/etc/group
类似/etc/passwd ，但说明的不是用户而是组。见group 的man页。

/etc/inittab
init 的配置文件。

/etc/issue
getty 在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。内容由系统管理员确定。

/etc/magic
file 的配置文件。包含不同文件格式的说明，file 基于它猜测文件类型。见magic 和file 的man页。

/etc/motd
Message Of The Day，成功登录后自动输出。内容由系统管理员确定。经常用于通告信息，如计划关机时间的警告。

/etc/mtab
当前安装的文件系统列表。由scripts初始化，并由mount 命令自动更新。需要一个当前安装的文件系统的列表时使用，例如df 命令。

/etc/shadow
在安装了影子口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow 中，而后者只对root可读。这使破译口令更困难。

/etc/login.defs
login 命令的配置文件。

/etc/printcap
类似/etc/termcap ，但针对打印机。语法不同。

/etc/profile , /etc/csh.login , /etc/csh.cshrc
登录或启动时Bourne或C shells执行的文件。这允许系统管理员为所有用户建立全局缺省环境。各shell见man页。

/etc/securetty
确认安全终端，即哪个终端允许root登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过modem或网络闯入系统并得到超级用户特权。

/etc/shells
列出可信任的shell。chsh 命令允许用户在本文件指定范围内改变登录shell。提供一台机器FTP服务的服务进程ftpd 检查用户shell是否列在 /etc/shells 文件中，如果不是将不允许该用户登录。

/etc/termcap
终端性能数据库。说明不同的终端用什么"转义序列"控制。写程序时不直接输出转义序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap 中查找要做的工作的正确序列。这样，多数的程序可以在多数终端上运行。见termcap 、 curs_termcap 和terminfo 的man页。

/dev目录
/dev 目录包括所有设备的设备文件。设备文件用特定的约定命名，这在设备列表中说明 (见[Anv])。设备文件在安装是产生，以后可以用 /dev/MAKEDEV 描述。 /dev/MAKEDEV.local 是系统管理员为本地设备文件(或连接)写的描述文稿 (即如一些非标准设备驱动不是标准MAKEDEV 的一部分)。

/usr文件系统
/usr 文件系统经常很大，因为所有程序安装在这里。 /usr 里的所有文件一般来自Linux distribution；本地安装的程序和其他东西在/usr/local 下。这样可能在升级新版系统或新distribution时无须重新安装全部程序。 /usr 的有些子目录在下面列出(一些不太重要的目录省略了，更多信息见FSSTND)。

/usr/X11R6
X Window系统的所有文件。为简化X的开发和安装，X的文件没有集成到系统中。 X自己在/usr/X11R6 下类似/usr 。

/usr/X386
类似/usr/X11R6 ，但是给X11 Release 5的。

/usr/bin
几乎所有用户命令。有些命令在/bin 或/usr/local/bin 中。

/usr/sbin
根文件系统不必要的系统管理命令，例如多数服务程序。

/usr/man , /usr/info , /usr/doc
手册页、GNU信息文档和各种其他文档文件。

/usr/include    C编程语言的头文件。为了一致性这实际上应该在/usr/lib 下，但传统上支持这个名字。
/usr/lib 程序或子系统的不变的数据文件，包括一些site-wide配置文件。名字lib来源于库(library); 编程的原始库存在/usr/lib 里.
/usr/local  本地安装的软件和其他文件放在这里.
/var文件系统
/var 包括系统一般运行时要改变的数据。每个系统是特定的，即不通过网络与其他计算机共享。
/var/catman
当要求格式化时的man页的cache。man页的源文件一般存在/usr/man/man* 中；有些man页可能有预格式化的版本，存在/usr/man/cat* 中。而其他的man页在第一次看时需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了。 (/var/catman 经常被清除，就象清除临时目录一样。)

/var/lib    系统正常运行时要改变的文件.
/var/local
/usr/local 中安装的程序的可变数据(即系统管理员安装的程序)。注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock 。

/var/lock
锁定文件。许多程序遵循在/var/lock 中产生一个锁定文件的约定，以支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件，将不试图使用这个设备或文件。

/var/log
各种程序的Log文件，特别是login (/var/log/wtmp log所有到系统的登录和注销) 和syslog (/var/log/messages 里存储所有核心和系统程序信息。 /var/log 里的文件经常不确定地增长，应该定期清除。

/var/run
保存到下次引导前有效的关于系统的信息文件。例如， /var/run/utmp 包含当前登录的用户的信息。

/var/spool
mail, news, 打印队列和其他队列工作的目录。每个不同的spool在/var/spool 下有自己的子目录，例如，用户的邮箱在/var/spool/mail 中。

/var/tmp
比/tmp 允许的大或需要存在较长时间的临时文件。 (虽然系统管理员可能不允许/var/tmp 有很旧的文件。)

/proc文件系统
/proc 文件系统是一个假的文件系统。它不存在在磁盘某个磁盘上。而是由核心在内存中产生。用于提供关于系统的信息(originally about processes, hence the name)。下面说明一些最重要的文件和目录。 /proc 文件系统在proc man页中有更详细的说明。

/proc/1
关于进程1的信息目录。每个进程在/proc 下有一个名为其进程号的目录。

/proc/cpuinfo
处理器信息，如类型、制造商、型号和性能。

/proc/devices
当前运行的核心配置的设备驱动的列表。

/proc/dma
显示当前使用的DMA通道。

/proc/filesystems
核心配置的文件系统。

/proc/interrupts
显示使用的中断，and how many of each there have been.

/proc/ioports 当前使用的I/O端口。
/proc/kcore   系统物理内存映象。与物理内存大小完全一样，但不实际占用这么多内存；it is generated on the fly as programs access it. (记住：除非你把它拷贝到什么地方，/proc 下没有任何东西占用任何磁盘空间。)
/proc/kmsg   核心输出的消息。也被送到syslog 。
/proc/ksyms   核心符号表。
/proc/loadavg   系统"平均负载"；3个没有意义的指示器指出系统当前的工作量。
/proc/meminfo
存储器使用信息，包括物理内存和swap。

/proc/modules
当前加载了哪些核心模块。

/proc/net
网络协议状态信息。

/proc/self  到查看/proc 的程序的进程目录的符号连接。当2个进程查看/proc 时，是不同的连接。这主要便于程序得到它自己的进程目录。/proc/stat     系统的不同状态，such as the number of page faults since the system was booted.
/proc/uptime    系统启动的时间长度。
/proc/version   核心版本。

　　注意所有上述文件给出易读的文本文件，有时可能是不易读的格式。有许多命令做了些格式化以更容易读。例如，free 程序读/proc/meminfo 并将给出的字节数转换为千字节(并增加了一些信息)。
